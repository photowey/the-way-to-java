# `JVM`

## 1.内存模型

### 1.1.`1.8`

- 线程隔离

  - 程序计数器
  - 本地方法栈
  - Java虚拟机栈

- 线程共享

  - 堆

    - ```json
      # 几乎所有对象都分配在这里,也是垃圾回收发生的主要区域,可用以下参数调整: 
      # -Xms: 堆的最小值;
      # -Xmx: 堆的最大值;
      # -Xmn: 新生代的大小;
      # -XX:NewSize: 新生代最小值;
      # -XX:MaxNewSize: 新生代最大值.
      ```

    - 

  - 元数据区

  - 直接内存

![](.\doc\jvm1_8_v2.jpg)



## 2.`JVM`中的对象

### 2.1.虚拟机中的对象

- 对象的分配

  - 检查加载
  - 分配内存
    - 指针碰撞
    - 空闲列表
    - 并发安全
    -  `CAS` 机制
    - 分配缓冲
  - 内存空间初始化
  - 设置
  - 对象初始化

- 对象的布局

  - 对象头

    - 运行时数据(`mark word`)

      - `hashcode`
      - `GC`标志
      - 对象分代年龄
      - 锁状态标志
      - 线程持有的锁
      - 偏向线程ID
      - 偏向时间戳

    - 类型指针(`klass pointer`)

      - ```json
        # 对象指向它的类元数据的指针
        # 虚拟机通过这个指针来确定这个对象是哪个类的实例
        # 指向类元数据 InstanceKlass, 确定该对象所属的类型
        ```
      
    - 如果是数组 -> 还需记录数组的长度
  
  - 实例数据
  
    - 它是对象真正存储的有效信息,包括程序代码中定义的各种类型的字段(本身+父类继承)
    - 规则
      - 相同宽度的字段总是被分配在一起
      - 父类中定义的变量会出现在子类之前
        - 如果 `CompactFileds` 参数为 `true`（默认: `true`）: 子类的窄变量可能插入到父类变量的空隙	
  
  - 对其填充
  
    - 不是必须的，没有特别的意义，仅仅起到占位符的作用



示例: 

```java
public class App {

    public static void main(String[] args) {
        Customer customer = new Customer();
    }

}

// com.photowey.jvm.in.action.objectheader.App
```



![object_header](./doc/object_header.png)



### 2.2.对象的访问定位

- 句柄

  - ```json
    # 使用句柄访问
    # Java 堆中将会划分出一块内存来作为句柄池
    # reference 中存储的就是对象的句柄地址,而句柄中包含了对象实例数据与类型数据各自的具体地址信息
    
    # 句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址
    # 在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针,而 reference 本身不需要修改
    ```

  - 

- 直接指针

  - ```json
    # 使用直接指针访问,
    # reference 中存储的直接就是对象地址
    
    # 使用直接指针访问方式的最大好处就是速度更快
    # 它节省了一次指针定位的时间开销
    # 由于对象的访问在 Java 中非常频繁,因此这类开销积少成多后也是一项非常可观的执行成本
    ```

  - 

### 2.3.堆内存分配策略

- 对象优先在 `Eden` 区分配

  - ```json
    # 虚拟机参数:
    # -Xms20m  堆空间初始 20m
    # -Xmx20m  堆空间最大 20m
    # -Xmn10m  新生代空间 10m
    # -XX:+PrintGCDetails 打印垃圾回收日志,程序退出时输出当前内存的分配情况
    
    # 大多数情况下,对象在新生代Eden区中分配.
    # 当 Eden 区没有足够空间分配时,虚拟机将发起一次 Minor GC.
    ```

  - 

- 大对象直接进入老年代

  - ```json
    # 虚拟机参数:
    # -Xms20m
    # -Xmx20m
    # -Xmn10m
    # -XX:+PrintGCDetails
    # -XX:PretenureSizeThreshold=4m  超过多少大小的对象直接进入老年代
    # -XX:+UseSerialGC
    
    # PretenureSizeThreshold 参数只对 Serial 和 ParNew 两款收集器有效.
    # 最典型的大对象是那种很长的字符串以及数组.
    # 目的:
    # 1.避免大量内存复制
    # 2.避免提前进行垃圾回收,明明内存有空间进行分配.
    ```

  - 

- 长期存活对象进入老年代

  - ```json
    # 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活,并且能被 Survivor容纳的话,将被移动到 Survivor 空间中,并将对象年龄设为1,对象在Survivor 区中每熬过一次 Minor GC,年龄就增加1,当它的年龄增加到一定程度(默认为15)时,就会被晋升到老年代中.
    ```

  - 

- 对象年龄动态判定

  - ```json
    # 如果在 Survivor 空间中相同年龄所有对象大小的综合大于 Survivor 空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代
    ```

  - 

- 空间分配担保

  - ```json
    # 在发生 Minor GC 之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间.
    ## -- 如果这个条件成立,那么Minor GC可以确保是安全的.
    ## -- 如果不成立,则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败.
    ## -- -- 如果允许,那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小,如果大于,将尝试着进行一次Minor GC,尽管这次Minor GC是有风险的,如果担保失败则会进行一次Full GC；
    ## -- -- 如果小于,或者HandlePromotionFailure设置不允许冒险,那这时也要改为进行一次 Full GC.
    ```

  - 



-- -



创建对象的步骤

- 1.判断对象对应的类是否: 加载、链接、初始化
- 2.为对象分配内存
  - 内存规整
    - 指针碰撞
  - 内存不规则
    - 虚拟机需要维护一个列表
    - 空闲列表分配
- 3.处理并发安全问题
  - 采用 `CAS` 失败重试、区域加索保证更新的原子性
  - 每个线程预先分配一个`TLAB` -- 通过 `-XX:+/-UseTLAB` 参数类设定
- 4.初始化分配到的空间
  - 所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用
    - 属性的默认初始化
    - 显示初始化
    - 代码块中初始化
    - 构造函数中初始化
- 5.设置对象的对象头
- 6.执行\<`init`\> 方法进行初始化